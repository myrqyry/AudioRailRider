import { Blueprint, TrackSegmentWithMeta as TrackSegment, seconds } from 'shared/types';

const getComponent = (segment: TrackSegment): string | undefined => {
    const comp = (segment as any).component ?? (segment as any).type;
    return typeof comp === 'string' ? comp : undefined;
};

const isIntense = (segment: TrackSegment): boolean => {
    const component = (getComponent(segment) || '').toLowerCase();
    switch (component) {
        case 'drop':
        case 'loop':
        case 'barrelRoll':
            return true;
        case 'turn': {
            const turnSegment = segment as Extract<TrackSegment, { component: 'turn' }>;
            // A turn is intense if it's sharp (small radius)
            return turnSegment.radius !== undefined && turnSegment.radius < 100;
        }
        default:
            return false;
    }
};

const createEasingSegment = (): TrackSegment => ({
    component: 'climb', // A straight segment is a climb with 0 angle
    angle: 0,
    length: 30, // A short segment to provide a breather
    intensity: 10, // Low intensity
    lightingEffect: 'none',
    environmentChange: 'none',
    audioSyncPoint: seconds(0),
});

/**
 * Validates and refines an AI-generated ride blueprint to make it more physically plausible.
 * It identifies consecutive intense segments and inserts short, straight "easing" segments
 * between them to allow for smoother transitions.
 * @param blueprint The original Blueprint from the AI.
 * @returns A new, refined Blueprint with easing segments added where necessary.
 */
/**
 * Validates and refines an AI-generated ride blueprint to ensure it is physically
 * plausible and provides a good user experience. It can insert "easing" segments
 * to smooth out transitions between intense track elements.
 *
 * @param {Blueprint} blueprint - The original blueprint generated by the AI.
 * @returns {Blueprint} A new, refined blueprint that is ready for track construction.
 * @throws {Error} If the provided blueprint is missing a valid `track` array.
 */
export const validateAndRefineBlueprint = (blueprint: Blueprint): Blueprint => {
    console.log("Starting blueprint validation and refinement...");
    console.log('[Validator] Blueprint structure:', { 
        hasTrack: !!blueprint.track, 
        trackType: typeof blueprint.track,
        trackLength: blueprint.track?.length,
        rideName: blueprint.rideName,
        blueprintKeys: Object.keys(blueprint)
    });
    
    const originalTrack = blueprint.track;
    
    // Defensive check: ensure track exists and is an array
    if (!originalTrack || !Array.isArray(originalTrack)) {
        console.error('[Validator] Invalid blueprint.track:', originalTrack);
        throw new Error('Blueprint is missing a valid track array');
    }
    
    // Ensure required fields have defaults
    if (!blueprint.rideName || typeof blueprint.rideName !== 'string') {
        blueprint.rideName = 'Audio Coaster';
    }
    if (!blueprint.moodDescription || typeof blueprint.moodDescription !== 'string') {
        blueprint.moodDescription = 'An immersive audio-driven experience';
    }
    if (!blueprint.palette || !Array.isArray(blueprint.palette) || blueprint.palette.length < 3) {
        blueprint.palette = ['#ffffff', '#00ffff', '#0d0a1f'];
    }
    
    if (originalTrack.length < 2) {
        return blueprint; // Not enough segments to need refinement
    }

    const refinedTrack: TrackSegment[] = [originalTrack[0]];

    for (let i = 1; i < originalTrack.length; i++) {
        const prevSegment = originalTrack[i - 1];
        const currentSegment = originalTrack[i];

        // Rule: Don't place two intense segments back-to-back without a breather.
        if (isIntense(prevSegment) && isIntense(currentSegment)) {
            console.log(`[Validator] Intense transition found between segment ${i-1} (${getComponent(prevSegment)}) and ${i} (${getComponent(currentSegment)}). Inserting easing segment.`);
            refinedTrack.push(createEasingSegment());
        }

        // Add more rules here in the future, e.g., checking for angle compatibility.

        refinedTrack.push(currentSegment);
    }

    console.log(`Blueprint refined. Original segments: ${originalTrack.length}, Refined segments: ${refinedTrack.length}`);

    return {
        ...blueprint,
        track: refinedTrack,
    };
};
