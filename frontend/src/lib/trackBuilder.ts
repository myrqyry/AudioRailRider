import * as THREE from 'three';
import { RideBlueprint, TrackSegmentWithMeta as TrackSegment, TrackData, seconds } from 'shared/types';
import { RIDE_CONFIG, DEFAULT_SPACING } from 'shared/constants';

/**
 * Builds the 3D track data from a ride blueprint.
 * This function converts the high-level blueprint from the AI into a series of
 * 3D points and up vectors that can be used to construct the rollercoaster track.
 * @param blueprint The ride blueprint generated by the AI.
 * @returns The processed track data ready for 3D rendering.
 */
import { AudioFeatures } from 'shared/types';

const normalizeSegmentComponent = (
    component: TrackSegment['component'] | string | undefined
): 'climb' | 'drop' | 'turn' | 'loop' | 'barrelRoll' | 'unknown' => {
    if (typeof component !== 'string') return 'unknown';
    const normalized = component.trim().toLowerCase();
    if (normalized === 'climb' || normalized.startsWith('climb')) return 'climb';
    if (normalized === 'drop' || normalized.startsWith('drop')) return 'drop';
    if (normalized === 'turn' || normalized.startsWith('turn')) return 'turn';
    if (normalized === 'loop' || normalized.includes('loop')) return 'loop';
    if (
        normalized === 'barrelroll' ||
        normalized === 'barrel_roll' ||
        normalized === 'barrel roll' ||
        normalized === 'roll' ||
        normalized.includes('roll')
    ) {
        return 'barrelRoll';
    }
    return 'unknown';
};

export const buildTrackData = (blueprint: RideBlueprint, audioFeatures?: AudioFeatures): TrackData => {
    const points: THREE.Vector3[] = [];
    const upVectors: THREE.Vector3[] = [];
    const segmentDetails: TrackData['segmentDetails'] = [];
    const segmentSpans: Array<{ start: number; end: number }> = [];

    let currentPos = new THREE.Vector3(0, 5, 0);
    let currentDir = new THREE.Vector3(0, 0, -1);
    let currentUp = new THREE.Vector3(0, 1, 0);

    const addSegment = (newPoints: THREE.Vector3[], newUps: THREE.Vector3[]): { start: number; end: number } | null => {
        if (!newPoints || newPoints.length === 0) return null;
        const startIndex = points.length;
        points.push(...newPoints);
        upVectors.push(...newUps);
        currentPos = newPoints[newPoints.length - 1];
        if (newPoints.length > 1) {
            currentDir.subVectors(newPoints[newPoints.length - 1], newPoints[newPoints.length - 2]).normalize();
        }
        currentUp = newUps[newUps.length - 1];
        return { start: startIndex, end: points.length - 1 };
    };
    
    // Add an initial flat segment
    const initialSegmentPoints: THREE.Vector3[] = [];
    const initialSegmentUps: THREE.Vector3[] = [];

    // Sanitize and clamp values
    const length = Math.max(1, Math.floor(Number(RIDE_CONFIG.INITIAL_TRACK_SEGMENT_LENGTH) || 0));
    let spacing = Number(RIDE_CONFIG.INITIAL_TRACK_SEGMENT_SPACING);
    if (!isFinite(spacing) || spacing < 0) spacing = DEFAULT_SPACING;

    for(let i=0; i<length; i++){
        initialSegmentPoints.push(currentPos.clone().add(currentDir.clone().multiplyScalar(i * spacing)));
        initialSegmentUps.push(currentUp.clone());
    }
    const initialSpan = addSegment(initialSegmentPoints, initialSegmentUps);
    if (initialSpan) segmentSpans.push(initialSpan);
    segmentDetails.push({
        intensity: 0,
        lightingEffect: 'none',
        environmentChange: 'none',
        audioSyncPoint: seconds(0)
    });

    blueprint.track.forEach((segment: TrackSegment, index: number) => {
        const segmentPoints: THREE.Vector3[] = [];
        const segmentUps: THREE.Vector3[] = [];
        const resolution = Math.max(1, Math.floor(RIDE_CONFIG.TRACK_SEGMENT_RESOLUTION ?? 100));

        const rawComponent = (segment as any).component ?? (segment as any).type;
        const normalizedComponent = normalizeSegmentComponent(rawComponent as TrackSegment['component']);

        switch (normalizedComponent) {
            case 'climb':
            case 'drop': {
                const typed = segment as Extract<TrackSegment, { component: 'climb' }> | Extract<TrackSegment, { component: 'drop' }>;
                const angleValue = typed.angle ?? (normalizedComponent === 'climb' ? 15 : -40);
                const angle = THREE.MathUtils.degToRad(THREE.MathUtils.clamp(angleValue, -90, 90));

                const lengthValue = typed.length ?? 150;
                const length = Math.max(10, lengthValue);

                const dir_horizontal = currentDir.clone();
                dir_horizontal.y = 0;
                dir_horizontal.normalize();

                const endPos = currentPos.clone()
                    .add(dir_horizontal.multiplyScalar(Math.cos(angle) * length))
                    .add(new THREE.Vector3(0, Math.sin(angle) * length, 0));
                
                for(let i = 1; i <= resolution; i++) {
                    const alpha = i / resolution;
                    segmentPoints.push(new THREE.Vector3().lerpVectors(currentPos, endPos, alpha));
                    segmentUps.push(currentUp.clone());
                }
                break;
            }
            case 'turn': {
                const typed = segment as Extract<TrackSegment, { component: 'turn' }>;
                const radiusValue = typed.radius ?? 80;
                const radius = Math.max(10, radiusValue);

                const angleValue = typed.angle ?? 90;
                const angle = THREE.MathUtils.degToRad(THREE.MathUtils.clamp(angleValue, -360, 360));

                const direction = typed.direction === 'left' ? 1 : -1;

                const turnAxis = new THREE.Vector3(0, 1, 0);
                const centerOffset = currentDir.clone().cross(turnAxis).multiplyScalar(radius * direction);
                const center = currentPos.clone().add(centerOffset);
                const startVec = currentPos.clone().sub(center);

                for (let i = 1; i <= resolution; i++) {
                    const alpha = i / resolution;
                    const newVec = startVec.clone().applyAxisAngle(turnAxis, angle * alpha * -direction);
                    segmentPoints.push(center.clone().add(newVec));
                    segmentUps.push(currentUp.clone());
                }
                break;
            }
            case 'loop': {
                const typed = segment as Extract<TrackSegment, { component: 'loop' }>;
                const radiusValue = typed.radius ?? 50;
                const radius = Math.max(10, radiusValue);
                const loopCenter = currentPos.clone().add(currentDir.clone().multiplyScalar(radius));
                
                for (let i = 1; i <= resolution; i++) {
                    const alpha = i / resolution;
                    const loopAngle = alpha * Math.PI * 2;
                    const point = new THREE.Vector3(
                        0,
                        Math.sin(loopAngle) * radius,
                        (Math.cos(loopAngle) - 1) * -radius
                    );
                    const up = new THREE.Vector3(0, Math.cos(loopAngle), -Math.sin(loopAngle));
                    
                    const matrix = new THREE.Matrix4().makeBasis(
                        currentDir.clone().cross(currentUp).normalize(), // right
                        currentUp,                                        // up  
                        currentDir                                        // forward
                    );
                    matrix.setPosition(currentPos);
                    point.applyMatrix4(matrix);
                    up.transformDirection(matrix);

                    segmentPoints.push(point);
                    segmentUps.push(up);
                }
                break;
            }
            case 'barrelRoll': {
                const typed = segment as Extract<TrackSegment, { component: 'barrelRoll' }>;
                const rotationsValue = typed.rotations ?? 1;
                const rotations = Math.max(1, Math.round(rotationsValue));

                const lengthValue = typed.length ?? 150;
                const length = Math.max(10, lengthValue);
                const endPos = currentPos.clone().add(currentDir.clone().multiplyScalar(length));

                for (let i = 1; i <= resolution; i++) {
                    const alpha = i / resolution;
                    const rollAngle = alpha * Math.PI * 2 * rotations;
                    segmentPoints.push(new THREE.Vector3().lerpVectors(currentPos, endPos, alpha));
                    segmentUps.push(currentUp.clone().applyAxisAngle(currentDir, rollAngle));
                }
                break;
            }
            case 'unknown': {
                console.warn('[TrackBuilder] Unsupported segment component, using straight fallback', {
                    index,
                    component: rawComponent
                });
                const fallbackLength = Math.max(10, (segment as { length?: number }).length ?? 80);
                for (let i = 1; i <= resolution; i++) {
                    const alpha = i / resolution;
                    segmentPoints.push(currentPos.clone().add(currentDir.clone().multiplyScalar(alpha * fallbackLength)));
                    segmentUps.push(currentUp.clone());
                }
                break;
            }
        }
        const span = addSegment(segmentPoints, segmentUps);
        if (span) {
            segmentSpans.push(span);
        } else if (segmentSpans.length > 0) {
            segmentSpans.push(segmentSpans[segmentSpans.length - 1]);
        } else {
            segmentSpans.push({ start: 0, end: points.length > 0 ? points.length - 1 : 0 });
        }
        segmentDetails.push({
            intensity: segment.intensity ?? 0,
            lightingEffect: segment.lightingEffect,
            environmentChange: segment.environmentChange,
            audioSyncPoint: segment.audioSyncPoint
        });
    });

    const totalSpanDenominator = Math.max(points.length - 1, 1);
    const segmentProgress = segmentSpans.map((span) => {
        const progress = span.end / totalSpanDenominator;
        return Number.isFinite(progress) ? THREE.MathUtils.clamp(progress, 0, 1) : 0;
    });

    console.log('[TrackBuilder] Generated track geometry', {
        pointCount: points.length,
        segmentCount: blueprint.track.length,
        segmentProgress,
    });

    return {
        path: points,
        upVectors: upVectors,
        railColor: blueprint.palette[0] || '#ffffff',
        glowColor: blueprint.palette[1] || '#00ffff',
        skyColor1: blueprint.palette[2] || '#0d0a1f',
        skyColor2: RIDE_CONFIG.DEFAULT_SKY_COLOR_2,
        segmentDetails: segmentDetails,
        segmentProgress,
        rideName: blueprint.rideName,
        moodDescription: blueprint.moodDescription,
        frameAnalyses: (audioFeatures && audioFeatures.frameAnalyses) || [],
        audioFeatures: audioFeatures || {
            duration: 0 as any,
            bpm: 120,
            energy: 0,
            spectralCentroid: 0,
            spectralFlux: 0,
            frameAnalyses: []
        },
    };
};
