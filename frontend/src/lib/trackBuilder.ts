import * as THREE from 'three';
import { RideBlueprint, TrackSegmentWithMeta as TrackSegment, TrackData, seconds } from 'shared/types';
import { RIDE_CONFIG, DEFAULT_SPACING } from 'shared/constants';

/**
 * Builds the 3D track data from a ride blueprint.
 * This function converts the high-level blueprint from the AI into a series of
 * 3D points and up vectors that can be used to construct the rollercoaster track.
 * @param blueprint The ride blueprint generated by the AI.
 * @returns The processed track data ready for 3D rendering.
 */
import { AudioFeatures } from 'shared/types';

const normalizeSegmentComponent = (
    component: TrackSegment['component'] | string | undefined
): 'climb' | 'drop' | 'turn' | 'loop' | 'barrelRoll' | 'unknown' => {
    if (typeof component !== 'string') return 'unknown';
    const normalized = component.trim().toLowerCase();
    if (normalized === 'climb' || normalized.startsWith('climb')) return 'climb';
    if (normalized === 'drop' || normalized.startsWith('drop')) return 'drop';
    if (normalized === 'turn' || normalized.startsWith('turn')) return 'turn';
    if (normalized === 'loop' || normalized.includes('loop')) return 'loop';
    if (
        normalized === 'barrelroll' ||
        normalized === 'barrel_roll' ||
        normalized === 'barrel roll' ||
        normalized === 'roll' ||
        normalized.includes('roll')
    ) {
        return 'barrelRoll';
    }
    return 'unknown';
};

export const buildTrackData = (blueprint: RideBlueprint, audioFeatures?: AudioFeatures): TrackData => {
    const SPEED_MULTIPLIER = 1.25;
    const points: THREE.Vector3[] = [];
    const upVectors: THREE.Vector3[] = [];
    const segmentDetails: TrackData['segmentDetails'] = [];
    const segmentSpans: Array<{ start: number; end: number }> = [];

    let currentPos = new THREE.Vector3(0, 5, 0);
    let currentDir = new THREE.Vector3(0, 0, -1);
    let currentUp = new THREE.Vector3(0, 1, 0);

    const addSegment = (newPoints: THREE.Vector3[], newUps: THREE.Vector3[]): { start: number; end: number } | null => {
        if (!newPoints || newPoints.length === 0) return null;
        const startIndex = points.length;
        points.push(...newPoints);
        upVectors.push(...newUps);
        currentPos = newPoints[newPoints.length - 1];
        if (newPoints.length > 1) {
            currentDir.subVectors(newPoints[newPoints.length - 1], newPoints[newPoints.length - 2]).normalize();
        }
        currentUp = newUps[newUps.length - 1];
        return { start: startIndex, end: points.length - 1 };
    };
    
    // Add an initial flat segment
    const initialSegmentPoints: THREE.Vector3[] = [];
    const initialSegmentUps: THREE.Vector3[] = [];

    // Sanitize and clamp values
    const length = Math.max(1, Math.floor(Number(RIDE_CONFIG.INITIAL_TRACK_SEGMENT_LENGTH) || 0));
    let spacing = Number(RIDE_CONFIG.INITIAL_TRACK_SEGMENT_SPACING) * SPEED_MULTIPLIER;
    if (!isFinite(spacing) || spacing < 0) spacing = DEFAULT_SPACING;

    for(let i=0; i<length; i++){
        initialSegmentPoints.push(currentPos.clone().add(currentDir.clone().multiplyScalar(i * spacing)));
        initialSegmentUps.push(currentUp.clone());
    }
    const initialSpan = addSegment(initialSegmentPoints, initialSegmentUps);
    if (initialSpan) segmentSpans.push(initialSpan);
    segmentDetails.push({
        intensity: 0,
        lightingEffect: 'none',
        environmentChange: 'none',
        audioSyncPoint: seconds(0)
    });

    blueprint.track.forEach((segment: TrackSegment, index: number) => {
        const segmentPoints: THREE.Vector3[] = [];
        const segmentUps: THREE.Vector3[] = [];
        const resolution = Math.max(1, Math.floor(RIDE_CONFIG.TRACK_SEGMENT_RESOLUTION ?? 100));

        const rawComponent = (segment as any).component ?? (segment as any).type;
        const normalizedComponent = normalizeSegmentComponent(rawComponent as TrackSegment['component']);

        switch (normalizedComponent) {
            case 'climb':
            case 'drop': {
                const typed = segment as Extract<TrackSegment, { component: 'climb' }> | Extract<TrackSegment, { component: 'drop' }>;
                const angleValue = typed.angle ?? (normalizedComponent === 'climb' ? 15 : -40);
                const angle = THREE.MathUtils.degToRad(THREE.MathUtils.clamp(angleValue, -90, 90));

                const lengthValue = typed.length ?? 150;
                const length = Math.max(10, lengthValue) * SPEED_MULTIPLIER;

                const dir_horizontal = currentDir.clone();
                dir_horizontal.y = 0;
                dir_horizontal.normalize();

                const endPos = currentPos.clone()
                    .add(dir_horizontal.multiplyScalar(Math.cos(angle) * length))
                    .add(new THREE.Vector3(0, Math.sin(angle) * length, 0));
                
                for(let i = 1; i <= resolution; i++) {
                    const alpha = i / resolution;
                    segmentPoints.push(new THREE.Vector3().lerpVectors(currentPos, endPos, alpha));
                    segmentUps.push(currentUp.clone());
                }
                break;
            }
            case 'turn': {
                const typed = segment as Extract<TrackSegment, { component: 'turn' }>;
                const radiusValue = typed.radius ?? 80;
                const radius = Math.max(10, radiusValue) * SPEED_MULTIPLIER;

                const angleValue = typed.angle ?? 90;
                const angle = THREE.MathUtils.degToRad(THREE.MathUtils.clamp(angleValue, -360, 360));

                const direction = typed.direction === 'left' ? 1 : -1;

                const turnAxis = new THREE.Vector3(0, 1, 0);
                const centerOffset = currentDir.clone().cross(turnAxis).multiplyScalar(radius * direction);
                const center = currentPos.clone().add(centerOffset);
                const startVec = currentPos.clone().sub(center);

                for (let i = 1; i <= resolution; i++) {
                    const alpha = i / resolution;
                    const newVec = startVec.clone().applyAxisAngle(turnAxis, angle * alpha * -direction);
                    segmentPoints.push(center.clone().add(newVec));
                    segmentUps.push(currentUp.clone());
                }
                break;
            }
            case 'loop': {
                const typed = segment as Extract<TrackSegment, { component: 'loop' }>;
                const radiusValue = typed.radius ?? 50;
                const radius = Math.max(10, radiusValue) * SPEED_MULTIPLIER;
                const forwardStretch = Math.max(radius * 1.5, (typed as any).length ? Math.max(20, Number((typed as any).length)) * SPEED_MULTIPLIER : radius * Math.PI * 0.75);

                const center = currentPos.clone().add(currentDir.clone().multiplyScalar(radius));

                for (let i = 1; i <= resolution; i++) {
                    const alpha = i / resolution;
                    const loopAngle = alpha * Math.PI * 2;
                    const upOffset = currentUp.clone().multiplyScalar(Math.sin(loopAngle) * radius);
                    const forwardBase = currentDir.clone().multiplyScalar(-Math.cos(loopAngle) * radius + alpha * forwardStretch);
                    const point = center.clone().add(upOffset).add(forwardBase);
                    segmentPoints.push(point);
                    segmentUps.push(currentUp.clone());
                }
                break;
            }
            case 'barrelRoll': {
                const typed = segment as Extract<TrackSegment, { component: 'barrelRoll' }>;
                const rotationsValue = typed.rotations ?? 1;
                const rotations = Math.max(1, Math.round(rotationsValue));

                const lengthValue = typed.length ?? 150;
                const length = Math.max(10, lengthValue) * SPEED_MULTIPLIER;
                const endPos = currentPos.clone().add(currentDir.clone().multiplyScalar(length));

                for (let i = 1; i <= resolution; i++) {
                    const alpha = i / resolution;
                    const rollAngle = alpha * Math.PI * 2 * rotations;
                    segmentPoints.push(new THREE.Vector3().lerpVectors(currentPos, endPos, alpha));
                    segmentUps.push(currentUp.clone().applyAxisAngle(currentDir, rollAngle));
                }
                break;
            }
            case 'unknown': {
                console.warn('[TrackBuilder] Unsupported segment component, using straight fallback', {
                    index,
                    component: rawComponent
                });
                const fallbackLength = Math.max(10, (segment as { length?: number }).length ?? 80) * SPEED_MULTIPLIER;
                for (let i = 1; i <= resolution; i++) {
                    const alpha = i / resolution;
                    segmentPoints.push(currentPos.clone().add(currentDir.clone().multiplyScalar(alpha * fallbackLength)));
                    segmentUps.push(currentUp.clone());
                }
                break;
            }
        }
        const span = addSegment(segmentPoints, segmentUps);
        if (span) {
            segmentSpans.push(span);
        } else if (segmentSpans.length > 0) {
            segmentSpans.push(segmentSpans[segmentSpans.length - 1]);
        } else {
            segmentSpans.push({ start: 0, end: points.length > 0 ? points.length - 1 : 0 });
        }
        segmentDetails.push({
            intensity: segment.intensity ?? 0,
            lightingEffect: segment.lightingEffect,
            environmentChange: segment.environmentChange,
            audioSyncPoint: segment.audioSyncPoint
        });
    });

    if (points.length > 2) {
        applyAudioWarp(points, upVectors, audioFeatures);
    }

    const totalSpanDenominator = Math.max(points.length - 1, 1);
    const segmentProgress = segmentSpans.map((span) => {
        const progress = span.end / totalSpanDenominator;
        return Number.isFinite(progress) ? THREE.MathUtils.clamp(progress, 0, 1) : 0;
    });

    console.log('[TrackBuilder] Generated track geometry', {
        pointCount: points.length,
        segmentCount: blueprint.track.length,
        segmentProgress,
    });

    return {
        path: points,
        upVectors: upVectors,
        railColor: blueprint.palette[0] || '#ffffff',
        glowColor: blueprint.palette[1] || '#00ffff',
        skyColor1: blueprint.palette[2] || '#0d0a1f',
        skyColor2: RIDE_CONFIG.DEFAULT_SKY_COLOR_2,
        segmentDetails: segmentDetails,
        segmentProgress,
        rideName: blueprint.rideName,
        moodDescription: blueprint.moodDescription,
        frameAnalyses: (audioFeatures && audioFeatures.frameAnalyses) || [],
        audioFeatures: audioFeatures || {
            duration: 0 as any,
            bpm: 120,
            energy: 0,
            spectralCentroid: 0,
            spectralFlux: 0,
            frameAnalyses: []
        },
    };
};

const applyAudioWarp = (points: THREE.Vector3[], upVectors: THREE.Vector3[], audioFeatures?: AudioFeatures) => {
    if (!audioFeatures) {
        applyDefaultWave(points, upVectors);
        return;
    }

    const frames = audioFeatures.frameAnalyses || [];
    if (!frames.length) {
        applyDefaultWave(points, upVectors);
        return;
    }

    const worldUp = new THREE.Vector3(0, 1, 0);
    const prev = new THREE.Vector3();
    const next = new THREE.Vector3();
    const tangent = new THREE.Vector3();
    const lateral = new THREE.Vector3();
    const rollUp = new THREE.Vector3();
    let smoothedLateral = 0;
    let smoothedVertical = 0;
    let smoothedRoll = 0;

    const frameCount = frames.length;
    const maxEnergy = frames.reduce((acc, f) => Math.max(acc, f.energy), 0) || 1;
    const maxFlux = frames.reduce((acc, f) => Math.max(acc, f.spectralFlux), 0) || 1;
    const maxCentroid = frames.reduce((acc, f) => Math.max(acc, f.spectralCentroid), 0) || 1;

    const sample = (progress: number, key: 'energy' | 'spectralFlux' | 'spectralCentroid') => {
        if (frameCount === 1) return frames[0][key];
        const scaled = THREE.MathUtils.clamp(progress, 0, 1) * (frameCount - 1);
        const idx = Math.floor(scaled);
        const nextIdx = Math.min(frameCount - 1, idx + 1);
        const t = scaled - idx;
        const a = frames[idx][key];
        const b = frames[nextIdx][key];
        return THREE.MathUtils.lerp(a, b, t);
    };

    for (let i = 1; i < points.length - 1; i++) {
        const progress = i / (points.length - 1);
        const fade = THREE.MathUtils.smoothstep(progress, 0.05, 0.95);
        const energyNorm = (sample(progress, 'energy') / maxEnergy) * fade;
        const fluxNorm = (sample(progress, 'spectralFlux') / maxFlux) * fade;
        const centroidNorm = (sample(progress, 'spectralCentroid') / maxCentroid) * fade;

        prev.copy(points[i - 1]);
        next.copy(points[i + 1]);
        tangent.copy(next).sub(prev);
        if (tangent.lengthSq() < 1e-6) continue;
        tangent.normalize();

        lateral.crossVectors(tangent, worldUp);
        if (lateral.lengthSq() < 1e-6) {
            lateral.set(1, 0, 0);
        } else {
            lateral.normalize();
        }

        const swirl = Math.sin(progress * Math.PI * 4 + fluxNorm * 6.0);
        const lift = Math.cos(progress * Math.PI * 3.2 + centroidNorm * 4.0);

        const targetLat = swirl * fluxNorm * 8.0;
        const targetVert = lift * energyNorm * 11.0;
        const targetRoll = swirl * 0.3 * fluxNorm + centroidNorm * 0.18;

        smoothedLateral = THREE.MathUtils.lerp(smoothedLateral, targetLat, 0.2);
        smoothedVertical = THREE.MathUtils.lerp(smoothedVertical, targetVert, 0.2);
        smoothedRoll = THREE.MathUtils.lerp(smoothedRoll, targetRoll, 0.18);

        points[i].addScaledVector(lateral, smoothedLateral);
        points[i].y += smoothedVertical;

        rollUp.copy(worldUp).applyAxisAngle(tangent, smoothedRoll).normalize();
        upVectors[i].lerp(rollUp, 0.45).normalize();
    }
};

const applyDefaultWave = (points: THREE.Vector3[], upVectors: THREE.Vector3[]) => {
    if (points.length < 3) return;
    const worldUp = new THREE.Vector3(0, 1, 0);
    const prev = new THREE.Vector3();
    const next = new THREE.Vector3();
    const tangent = new THREE.Vector3();
    const lateral = new THREE.Vector3();
    let smoothedLateral = 0;
    let smoothedVertical = 0;

    for (let i = 1; i < points.length - 1; i++) {
        const progress = i / (points.length - 1);
        const fade = THREE.MathUtils.smoothstep(progress, 0.05, 0.95);
        const wave = Math.sin(progress * Math.PI * 3.0) * fade;

        prev.copy(points[i - 1]);
        next.copy(points[i + 1]);
        tangent.copy(next).sub(prev);
        if (tangent.lengthSq() < 1e-6) continue;
        tangent.normalize();

        lateral.crossVectors(tangent, worldUp);
        if (lateral.lengthSq() < 1e-6) {
            lateral.set(1, 0, 0);
        } else {
            lateral.normalize();
        }

        const targetLat = wave * 6.5;
        const targetVert = wave * 8.0;
        smoothedLateral = THREE.MathUtils.lerp(smoothedLateral, targetLat, 0.22);
        smoothedVertical = THREE.MathUtils.lerp(smoothedVertical, targetVert, 0.22);

        points[i].addScaledVector(lateral, smoothedLateral);
        points[i].y += smoothedVertical;
        upVectors[i].lerp(worldUp, 0.6).normalize();
    }
};
