import * as THREE from 'three';
import {
    Blueprint,
    TrackSegmentWithMeta as TrackSegment,
    TrackData,
    seconds,
    AudioFeatures,
    SynestheticBlueprintLayer,
    SynestheticGeometry,
} from 'shared/types';
import { RIDE_CONFIG, DEFAULT_SPACING } from 'shared/constants';

/**
 * Builds the 3D track data from a ride blueprint.
 * This function converts the high-level blueprint from the AI into a series of
 * 3D points and up vectors that can be used to construct the rollercoaster track.
 * @param blueprint The ride blueprint generated by the AI.
 * @returns The processed track data ready for 3D rendering.
 */

const normalizeSegmentComponent = (
    component: TrackSegment['component'] | string | undefined
): 'climb' | 'drop' | 'turn' | 'loop' | 'barrelRoll' | 'unknown' => {
    if (typeof component !== 'string') return 'unknown';
    const normalized = component.trim().toLowerCase();
    if (normalized === 'climb' || normalized.startsWith('climb')) return 'climb';
    if (normalized === 'drop' || normalized.startsWith('drop')) return 'drop';
    if (normalized === 'turn' || normalized.startsWith('turn')) return 'turn';
    if (normalized === 'loop' || normalized.includes('loop')) return 'loop';
    if (
        normalized === 'barrelroll' ||
        normalized === 'barrel_roll' ||
        normalized === 'barrel roll' ||
        normalized === 'roll' ||
        normalized.includes('roll')
    ) {
        return 'barrelRoll';
    }
    return 'unknown';
};

const clamp01 = (value: number | undefined, fallback: number): number => {
    if (!Number.isFinite(value as number)) {
        return THREE.MathUtils.clamp(fallback, 0, 1);
    }
    return THREE.MathUtils.clamp(value as number, 0, 1);
};

const sanitizeSynestheticLayer = (raw: unknown): SynestheticBlueprintLayer | null => {
    if (!raw || typeof raw !== 'object') return null;
    const source = raw as Record<string, unknown>;

    let geometry: SynestheticGeometry | null = null;
    if (source.geometry && typeof source.geometry === 'object') {
        const g = source.geometry as Record<string, unknown>;
        const breathingDriver = typeof g.breathingDriver === 'string' ? g.breathingDriver.toString().toLowerCase() : undefined;
        geometry = {
            wireframeDensity: Number.isFinite(g.wireframeDensity as number) ? clamp01(g.wireframeDensity as number, 0.55) : undefined,
            impossiblePhysics: typeof g.impossiblePhysics === 'object' && g.impossiblePhysics !== null
                ? {
                    enabled: typeof (g.impossiblePhysics as any).enabled === 'boolean' ? (g.impossiblePhysics as any).enabled : false,
                    intensity: Number.isFinite((g.impossiblePhysics as any).intensity as number) ? clamp01((g.impossiblePhysics as any).intensity as number, 0.5) : undefined,
                    frequency: Number.isFinite((g.impossiblePhysics as any).frequency as number) ? Math.max(0.1, (g.impossiblePhysics as any).frequency as number) : undefined,
                }
                : undefined,
            organicBreathing: Number.isFinite(g.organicBreathing as number) ? clamp01(g.organicBreathing as number, 0.4) : undefined,
            breathingDriver: breathingDriver === 'energy' || breathingDriver === 'spectralflux' || breathingDriver === 'spectralcentroid'
                ? (breathingDriver === 'spectralflux'
                    ? 'spectralFlux'
                    : breathingDriver === 'spectralcentroid'
                        ? 'spectralCentroid'
                        : 'energy')
                : undefined,
        };
    }

    let particles: SynestheticBlueprintLayer['particles'] | null = null;
    if (source.particles && typeof source.particles === 'object') {
        const p = source.particles as Record<string, unknown>;
        particles = {
            connectionDensity: Number.isFinite(p.connectionDensity as number) ? clamp01(p.connectionDensity as number, 0.45) : undefined,
            resonanceThreshold: Number.isFinite(p.resonanceThreshold as number) ? clamp01(p.resonanceThreshold as number, 0.4) : undefined,
            lifespanSeconds: Number.isFinite(p.lifespanSeconds as number) ? Math.max(0, p.lifespanSeconds as number) : undefined,
            persistence: Number.isFinite(p.persistence as number) ? clamp01(p.persistence as number, 0.5) : undefined,
        };
    }

    let atmosphere: SynestheticBlueprintLayer['atmosphere'] | null = null;
    if (source.atmosphere && typeof source.atmosphere === 'object') {
        const a = source.atmosphere as Record<string, unknown>;
        atmosphere = {
            skyMood: typeof a.skyMood === 'string' ? a.skyMood : undefined,
            turbulenceBias: Number.isFinite(a.turbulenceBias as number) ? (a.turbulenceBias as number) : undefined,
            passionIntensity: Number.isFinite(a.passionIntensity as number) ? Math.max(0, a.passionIntensity as number) : undefined,
            tint: typeof a.tint === 'string' ? a.tint : undefined,
        };
    }

    if (!geometry && !particles && !atmosphere) return null;
    return {
        geometry,
        particles,
        atmosphere,
    };
};

const computePolylineLength = (pts: THREE.Vector3[]): number => {
    if (pts.length < 2) return 0;
    let total = 0;
    for (let i = 1; i < pts.length; i++) {
        total += pts[i].distanceTo(pts[i - 1]);
    }
    return total;
};

const MAX_AUDIO_LATERAL_SHIFT = 18;
const MAX_AUDIO_VERTICAL_SHIFT = 24;
const MAX_DEFAULT_LATERAL_SHIFT = 12;
const MAX_DEFAULT_VERTICAL_SHIFT = 16;
const AUDIO_WARP_BLEND = 0.55;
const DEFAULT_WARP_BLEND = 0.4;
const ROLL_CLAMP = Math.PI / 4;

/**
 * Constructs the 3D track data from a high-level `Blueprint`.
 * This involves converting abstract segments (like 'climb', 'turn') into a
 * series of 3D points and up-vectors that define the rollercoaster's path.
 * It also applies procedural "warping" to the track based on audio features.
 *
 * @param {Blueprint} blueprint - The high-level ride description.
 * @param {AudioFeatures} [audioFeatures] - The analyzed features of the audio track.
 * @returns {TrackData} The processed, render-ready track data.
 */
import { useAppStore } from './store';

export const buildTrackData = (blueprint: Blueprint, audioFeatures?: AudioFeatures, breathingIntensity?: number): TrackData => {
    const SPEED_MULTIPLIER = 1.25;
    const points: THREE.Vector3[] = [];
    const upVectors: THREE.Vector3[] = [];
    const segmentDetails: TrackData['segmentDetails'] = [];
    const segmentSpans: Array<{ start: number; end: number }> = [];
    const segmentMetrics: Array<{
        index: number;
        component: string;
        computedLength: number;
        sampleCount: number;
        source: Record<string, number | string | undefined>;
    }> = [];
    const synesthetic = sanitizeSynestheticLayer((blueprint as unknown as { synesthetic?: SynestheticBlueprintLayer }).synesthetic);
    const geometrySettings = synesthetic?.geometry ?? null;

    let currentPos = new THREE.Vector3(0, 5, 0);
    let currentDir = new THREE.Vector3(0, 0, -1);
    let currentUp = new THREE.Vector3(0, 1, 0);

    const addSegment = (newPoints: THREE.Vector3[], newUps: THREE.Vector3[]): { start: number; end: number } | null => {
        if (!newPoints || newPoints.length === 0) return null;
        const startIndex = points.length;
        points.push(...newPoints);
        upVectors.push(...newUps);
        currentPos = newPoints[newPoints.length - 1];
        if (newPoints.length > 1) {
            currentDir.subVectors(newPoints[newPoints.length - 1], newPoints[newPoints.length - 2]).normalize();
        }
        currentUp = newUps[newUps.length - 1];
        return { start: startIndex, end: points.length - 1 };
    };
    
    // Add an initial flat segment
    const initialSegmentPoints: THREE.Vector3[] = [];
    const initialSegmentUps: THREE.Vector3[] = [];

    // Sanitize and clamp values
    const length = Math.max(1, Math.floor(Number(RIDE_CONFIG.INITIAL_TRACK_SEGMENT_LENGTH) || 0));
    let spacing = Number(RIDE_CONFIG.INITIAL_TRACK_SEGMENT_SPACING) * SPEED_MULTIPLIER;
    if (!isFinite(spacing) || spacing < 0) spacing = DEFAULT_SPACING;

    for(let i=0; i<length; i++){
        initialSegmentPoints.push(currentPos.clone().add(currentDir.clone().multiplyScalar(i * spacing)));
        initialSegmentUps.push(currentUp.clone());
    }
    const initialSpan = addSegment(initialSegmentPoints, initialSegmentUps);
    if (initialSpan) segmentSpans.push(initialSpan);
    segmentMetrics.push({
        index: -1,
        component: 'initial',
        computedLength: computePolylineLength(initialSegmentPoints),
        sampleCount: initialSegmentPoints.length,
        source: {
            spacing,
            samples: length,
        },
    });
    segmentDetails.push({
        intensity: 0,
        lightingEffect: 'none',
        environmentChange: 'none',
        audioSyncPoint: seconds(0)
    });

    blueprint.track.forEach((segment: TrackSegment, index: number) => {
        const segmentPoints: THREE.Vector3[] = [];
        const segmentUps: THREE.Vector3[] = [];
        const resolution = Math.max(1, Math.floor(RIDE_CONFIG.TRACK_SEGMENT_RESOLUTION ?? 100));

        const rawComponent = (segment as any).component ?? (segment as any).type;
        const normalizedComponent = normalizeSegmentComponent(rawComponent as TrackSegment['component']);
    const metricsSource: Record<string, number | string | undefined> = {};

        // Get breathing intensity from argument or store
        const intensity = typeof breathingIntensity === 'number' ? breathingIntensity : (useAppStore.getState().breathingIntensity ?? 1.0);
        switch (normalizedComponent) {
            case 'climb':
            case 'drop': {
                const typed = segment as Extract<TrackSegment, { component: 'climb' }> | Extract<TrackSegment, { component: 'drop' }>;
                const angleValue = typed.angle ?? (normalizedComponent === 'climb' ? 15 : -40);
                const angle = THREE.MathUtils.degToRad(THREE.MathUtils.clamp(angleValue, -90, 90));
        metricsSource.length = typed.length;
        metricsSource.angle = angleValue;

                const lengthValue = typed.length ?? 150;
                const length = Math.max(10, lengthValue) * SPEED_MULTIPLIER;

                const dir_horizontal = currentDir.clone();
                dir_horizontal.y = 0;
                dir_horizontal.normalize();

                const endPos = currentPos.clone()
                    .add(dir_horizontal.multiplyScalar(Math.cos(angle) * length))
                    .add(new THREE.Vector3(0, Math.sin(angle) * length, 0));
                
                for(let i = 1; i <= resolution; i++) {
                    const alpha = i / resolution;
                    segmentPoints.push(new THREE.Vector3().lerpVectors(currentPos, endPos, alpha));
                    segmentUps.push(currentUp.clone());
                }
                // Apply breathing deformation
                if (audioFeatures) {
                    const { applyBreathingToGeometry } = require('./procedural/TrackComposer');
                    applyBreathingToGeometry(segmentPoints, audioFeatures, intensity);
                }
                break;
            }
            case 'turn': {
                const typed = segment as Extract<TrackSegment, { component: 'turn' }>;
                const radiusValue = typed.radius ?? 80;
                const radius = Math.max(10, radiusValue) * SPEED_MULTIPLIER;

                const angleValue = typed.angle ?? 90;
                const angle = THREE.MathUtils.degToRad(THREE.MathUtils.clamp(angleValue, -360, 360));
                metricsSource.radius = typed.radius;
                metricsSource.angle = angleValue;
                metricsSource.direction = typed.direction;
                metricsSource.length = (segment as { length?: number }).length;

                const direction = typed.direction === 'left' ? 1 : -1;

                const turnAxis = new THREE.Vector3(0, 1, 0);
                const centerOffset = currentDir.clone().cross(turnAxis).multiplyScalar(radius * direction);
                const center = currentPos.clone().add(centerOffset);
                const startVec = currentPos.clone().sub(center);

                for (let i = 1; i <= resolution; i++) {
                    const alpha = i / resolution;
                    const newVec = startVec.clone().applyAxisAngle(turnAxis, angle * alpha * -direction);
                    segmentPoints.push(center.clone().add(newVec));
                    segmentUps.push(currentUp.clone());
                }
                // Apply breathing deformation
                if (audioFeatures) {
                    const { applyBreathingToGeometry } = require('./procedural/TrackComposer');
                    applyBreathingToGeometry(segmentPoints, audioFeatures, intensity);
                }
                break;
            }
            case 'loop': {
                const typed = segment as Extract<TrackSegment, { component: 'loop' }>;
                const radiusValue = typed.radius ?? 50;
                const radius = Math.max(10, radiusValue) * SPEED_MULTIPLIER;
                const forwardStretch = Math.max(radius * 1.5, (typed as any).length ? Math.max(20, Number((typed as any).length)) * SPEED_MULTIPLIER : radius * Math.PI * 0.75);
                metricsSource.radius = typed.radius;
                metricsSource.length = (typed as { length?: number }).length;

                const center = currentPos.clone().add(currentDir.clone().multiplyScalar(radius));

                for (let i = 1; i <= resolution; i++) {
                    const alpha = i / resolution;
                    const loopAngle = alpha * Math.PI * 2;
                    const upOffset = currentUp.clone().multiplyScalar(Math.sin(loopAngle) * radius);
                    const forwardBase = currentDir.clone().multiplyScalar(-Math.cos(loopAngle) * radius + alpha * forwardStretch);
                    const point = center.clone().add(upOffset).add(forwardBase);
                    segmentPoints.push(point);
                    segmentUps.push(currentUp.clone());
                }
                // Apply breathing deformation
                if (audioFeatures) {
                    const { applyBreathingToGeometry } = require('./procedural/TrackComposer');
                    applyBreathingToGeometry(segmentPoints, audioFeatures, intensity);
                }
                break;
            }
            case 'barrelRoll': {
                const typed = segment as Extract<TrackSegment, { component: 'barrelRoll' }>;
                const rotationsValue = typed.rotations ?? 1;
                const rotations = Math.max(1, Math.round(rotationsValue));
                metricsSource.length = typed.length;
                metricsSource.rotations = rotationsValue;

                const lengthValue = typed.length ?? 150;
                const length = Math.max(10, lengthValue) * SPEED_MULTIPLIER;
                const endPos = currentPos.clone().add(currentDir.clone().multiplyScalar(length));

                for (let i = 1; i <= resolution; i++) {
                    const alpha = i / resolution;
                    const rollAngle = alpha * Math.PI * 2 * rotations;
                    segmentPoints.push(new THREE.Vector3().lerpVectors(currentPos, endPos, alpha));
                    segmentUps.push(currentUp.clone().applyAxisAngle(currentDir, rollAngle));
                }
                // Apply breathing deformation
                if (audioFeatures) {
                    const { applyBreathingToGeometry } = require('./procedural/TrackComposer');
                    applyBreathingToGeometry(segmentPoints, audioFeatures, intensity);
                }
                break;
            }
            case 'unknown': {
                console.warn('[TrackBuilder] Unsupported segment component, using straight fallback', {
                    index,
                    component: rawComponent
                });
                const fallbackLength = Math.max(10, (segment as { length?: number }).length ?? 80) * SPEED_MULTIPLIER;
                metricsSource.length = (segment as { length?: number }).length;
                for (let i = 1; i <= resolution; i++) {
                    const alpha = i / resolution;
                    segmentPoints.push(currentPos.clone().add(currentDir.clone().multiplyScalar(alpha * fallbackLength)));
                    segmentUps.push(currentUp.clone());
                }
                break;
            }
        }
        const computedLength = computePolylineLength(segmentPoints);
        const span = addSegment(segmentPoints, segmentUps);
        if (span) {
            segmentSpans.push(span);
        } else if (segmentSpans.length > 0) {
            segmentSpans.push(segmentSpans[segmentSpans.length - 1]);
        } else {
            segmentSpans.push({ start: 0, end: points.length > 0 ? points.length - 1 : 0 });
        }
        segmentMetrics.push({
            index,
            component: normalizedComponent,
            computedLength,
            sampleCount: segmentPoints.length,
            source: metricsSource,
        });
        segmentDetails.push({
            intensity: segment.intensity ?? 0,
            lightingEffect: segment.lightingEffect,
            environmentChange: segment.environmentChange,
            audioSyncPoint: segment.audioSyncPoint
        });
    });

    if (points.length > 2) {
        applyAudioWarp(points, upVectors, audioFeatures, geometrySettings);
    }

    const totalSpanDenominator = Math.max(points.length - 1, 1);
    const segmentProgress = segmentSpans.map((span) => {
        const progress = span.end / totalSpanDenominator;
        return Number.isFinite(progress) ? THREE.MathUtils.clamp(progress, 0, 1) : 0;
    });

    let totalLength = 0;
    let minX = Number.POSITIVE_INFINITY;
    let minY = Number.POSITIVE_INFINITY;
    let minZ = Number.POSITIVE_INFINITY;
    let maxX = Number.NEGATIVE_INFINITY;
    let maxY = Number.NEGATIVE_INFINITY;
    let maxZ = Number.NEGATIVE_INFINITY;
    for (let i = 0; i < points.length; i++) {
        const p = points[i];
        if (i > 0) {
            totalLength += p.distanceTo(points[i - 1]);
        }
        if (p.x < minX) minX = p.x;
        if (p.y < minY) minY = p.y;
        if (p.z < minZ) minZ = p.z;
        if (p.x > maxX) maxX = p.x;
        if (p.y > maxY) maxY = p.y;
        if (p.z > maxZ) maxZ = p.z;
    }

    console.log('[TrackBuilder] Generated track geometry', {
        pointCount: points.length,
        segmentCount: blueprint.track.length,
        segmentProgress,
        metrics: {
            totalApproxLength: Number(totalLength.toFixed(1)),
            bounds: {
                x: [Number(minX.toFixed(2)), Number(maxX.toFixed(2))],
                y: [Number(minY.toFixed(2)), Number(maxY.toFixed(2))],
                z: [Number(minZ.toFixed(2)), Number(maxZ.toFixed(2))],
                span: {
                    x: Number((maxX - minX).toFixed(2)),
                    y: Number((maxY - minY).toFixed(2)),
                    z: Number((maxZ - minZ).toFixed(2)),
                },
            },
            perSegment: segmentMetrics,
        },
    });

    return {
        path: points,
        upVectors: upVectors,
        railColor: blueprint.palette[0] || '#ffffff',
        glowColor: blueprint.palette[1] || '#00ffff',
        skyColor1: blueprint.palette[2] || '#0d0a1f',
        skyColor2: RIDE_CONFIG.DEFAULT_SKY_COLOR_2,
        segmentDetails: segmentDetails,
        segmentProgress,
        rideName: blueprint.rideName,
        moodDescription: blueprint.moodDescription,
        frameAnalyses: (audioFeatures && audioFeatures.frameAnalyses) || [],
        audioFeatures: audioFeatures || {
            duration: 0 as any,
            bpm: 120,
            energy: 0,
            spectralCentroid: 0,
            spectralFlux: 0,
            frameAnalyses: []
        },
        // Attach any timeline events from the blueprint so runtime consumers
        // (VisualEffects) can schedule them appropriately.
        events: Array.isArray((blueprint as any).events) ? (blueprint as any).events : [],
        synesthetic,
    };
};

const applyAudioWarp = (
    points: THREE.Vector3[],
    upVectors: THREE.Vector3[],
    audioFeatures: AudioFeatures | undefined,
    geometrySettings: SynestheticGeometry | null
) => {
    if (!audioFeatures) {
        applyDefaultWave(points, upVectors, geometrySettings);
        return;
    }

    const frames = audioFeatures.frameAnalyses || [];
    if (!frames.length) {
        applyDefaultWave(points, upVectors, geometrySettings);
        return;
    }

    const basePoints = points.map((p) => p.clone());
    const baseUpVectors = upVectors.map((u) => u.clone());

    const wireframeDensity = clamp01(geometrySettings?.wireframeDensity, 0.55);
    const breathingStrength = clamp01(geometrySettings?.organicBreathing, 0.4);
    const impossiblePhysicsEnabled = Boolean(geometrySettings?.impossiblePhysics?.enabled);
    const impossiblePhysicsIntensity = clamp01(geometrySettings?.impossiblePhysics?.intensity, 0.5);
    const impossiblePhysicsFrequency = geometrySettings?.impossiblePhysics?.frequency ?? 1.0;
    const breathingDriver = geometrySettings?.breathingDriver ?? 'energy';
    const bpm = Number.isFinite(audioFeatures.bpm) ? Math.max(30, audioFeatures.bpm || 120) : 120;
    const breathFrequency = (bpm / 60) * 0.5;
    const macroBend = 28 + wireframeDensity * 45;
    const macroLift = 24 + breathingStrength * 36;

    const worldUp = new THREE.Vector3(0, 1, 0);
    const prev = new THREE.Vector3();
    const next = new THREE.Vector3();
    const tangent = new THREE.Vector3();
    const lateral = new THREE.Vector3();
    const rollUp = new THREE.Vector3();
    const displaced = new THREE.Vector3();
    const verticalOffset = new THREE.Vector3();
    let smoothedLateral = 0;
    let smoothedVertical = 0;
    let smoothedRoll = 0;

    const frameCount = frames.length;
    const maxEnergy = frames.reduce((acc, f) => Math.max(acc, f.energy), 0) || 1;
    const maxFlux = frames.reduce((acc, f) => Math.max(acc, f.spectralFlux), 0) || 1;
    const maxCentroid = frames.reduce((acc, f) => Math.max(acc, f.spectralCentroid), 0) || 1;

    const sample = (progress: number, key: 'energy' | 'spectralFlux' | 'spectralCentroid') => {
        if (frameCount === 1) return frames[0][key];
        const scaled = THREE.MathUtils.clamp(progress, 0, 1) * (frameCount - 1);
        const idx = Math.floor(scaled);
        const nextIdx = Math.min(frameCount - 1, idx + 1);
        const t = scaled - idx;
        const a = frames[idx][key];
        const b = frames[nextIdx][key];
        return THREE.MathUtils.lerp(a, b, t);
    };

    const warpBlend = THREE.MathUtils.clamp(AUDIO_WARP_BLEND + breathingStrength * 0.15, 0.35, 0.72);

    for (let i = 1; i < points.length - 1; i++) {
        const progress = i / (points.length - 1);
        const fade = THREE.MathUtils.smoothstep(progress, 0.05, 0.95);
        const energyNorm = (sample(progress, 'energy') / maxEnergy) * fade;
        const fluxNorm = (sample(progress, 'spectralFlux') / maxFlux) * fade;
        const centroidNorm = (sample(progress, 'spectralCentroid') / maxCentroid) * fade;
        const driverNorm = breathingDriver === 'spectralFlux'
            ? fluxNorm
            : breathingDriver === 'spectralCentroid'
                ? centroidNorm
                : energyNorm;

        const basePrev = basePoints[i - 1];
        const baseCurrent = basePoints[i];
        const baseNext = basePoints[i + 1];

        prev.copy(basePrev);
        next.copy(baseNext);
        tangent.copy(baseNext).sub(basePrev);
        if (tangent.lengthSq() < 1e-6) continue;
        tangent.normalize();

        lateral.crossVectors(tangent, worldUp);
        if (lateral.lengthSq() < 1e-6) {
            lateral.set(1, 0, 0);
        } else {
            lateral.normalize();
        }

        const swirlFrequency = 2.6 + wireframeDensity * 3.2;
        const swirl = Math.sin(progress * Math.PI * swirlFrequency + fluxNorm * (5.0 + wireframeDensity * 3.2));
        const lift = Math.cos(progress * Math.PI * (2.4 + wireframeDensity * 0.8) + centroidNorm * (3.5 + wireframeDensity * 2.4));

        let targetLat = swirl * fluxNorm * (8.0 + wireframeDensity * 6.0);
        let targetVert = lift * energyNorm * (10.0 + breathingStrength * 6.5);
        const targetRoll = swirl * 0.22 * fluxNorm + centroidNorm * 0.14;

        const macroCurve = Math.sin(progress * Math.PI * 1.1) * macroBend * fade;
        const macroRise = Math.cos(progress * Math.PI * 0.7 + fluxNorm * 1.8) * macroLift * fade;
        targetLat += macroCurve;
        targetVert += macroRise * 0.75;

        if (breathingStrength > 0.001) {
            const globalPhase = progress * Math.PI * 2 * breathFrequency;
            const breathPulse = Math.sin(globalPhase + driverNorm * Math.PI * 1.5);
            const breathLift = breathPulse * breathingStrength * (7.5 + wireframeDensity * 4.0) * fade;
            const breathSway = Math.cos(globalPhase * 0.65 + fluxNorm * 2.0) * breathingStrength * centroidNorm * (5.0 + wireframeDensity * 3.2) * fade;
            targetVert += breathLift;
            targetLat += breathSway;
        }

        if (impossiblePhysicsEnabled) {
            const tumble = Math.sin(progress * Math.PI * (3.6 * impossiblePhysicsFrequency + wireframeDensity * 3.0) + energyNorm * 5.0) * fluxNorm;
            const lateralInvert = Math.cos(progress * Math.PI * 2.6 * impossiblePhysicsFrequency + centroidNorm * 3.6) * energyNorm;
            targetVert += tumble * 2.4 * impossiblePhysicsIntensity;
            targetLat += lateralInvert * 2.1 * impossiblePhysicsIntensity;
        }

        targetLat = THREE.MathUtils.clamp(targetLat, -MAX_AUDIO_LATERAL_SHIFT, MAX_AUDIO_LATERAL_SHIFT);
        targetVert = THREE.MathUtils.clamp(targetVert, -MAX_AUDIO_VERTICAL_SHIFT, MAX_AUDIO_VERTICAL_SHIFT);

        // Use fixed lerp factors to prevent numerical instability from rapidly changing audio features.
        smoothedLateral = THREE.MathUtils.lerp(smoothedLateral, targetLat, 0.08);
        smoothedVertical = THREE.MathUtils.lerp(smoothedVertical, targetVert, 0.09);
        smoothedRoll = THREE.MathUtils.lerp(smoothedRoll, targetRoll, 0.14);

        displaced.copy(baseCurrent)
            .addScaledVector(lateral, smoothedLateral)
            .addScaledVector(worldUp, smoothedVertical);

        points[i].lerpVectors(baseCurrent, displaced, warpBlend);

        const clampedRoll = THREE.MathUtils.clamp(smoothedRoll, -ROLL_CLAMP, ROLL_CLAMP);
        rollUp.copy(worldUp).applyAxisAngle(tangent, clampedRoll).normalize();
        upVectors[i].copy(baseUpVectors[i]).lerp(rollUp, warpBlend * 0.6).normalize();
    }
};

const applyDefaultWave = (points: THREE.Vector3[], upVectors: THREE.Vector3[], geometrySettings: SynestheticGeometry | null) => {
    if (points.length < 3) return;
    const basePoints = points.map((p) => p.clone());
    const baseUpVectors = upVectors.map((u) => u.clone());

    const worldUp = new THREE.Vector3(0, 1, 0);
    const prev = new THREE.Vector3();
    const next = new THREE.Vector3();
    const tangent = new THREE.Vector3();
    const lateral = new THREE.Vector3();
    const displaced = new THREE.Vector3();
    let smoothedLateral = 0;
    let smoothedVertical = 0;

    const wireframeDensity = clamp01(geometrySettings?.wireframeDensity, 0.45);
    const breathingStrength = clamp01(geometrySettings?.organicBreathing, 0.35);
    const impossiblePhysicsEnabled = Boolean(geometrySettings?.impossiblePhysics?.enabled);
    const impossiblePhysicsIntensity = clamp01(geometrySettings?.impossiblePhysics?.intensity, 0.5);
    const impossiblePhysicsFrequency = geometrySettings?.impossiblePhysics?.frequency ?? 1.0;
    const macroBend = 22 + wireframeDensity * 34;
    const macroLift = 18 + breathingStrength * 28;
    const warpBlend = THREE.MathUtils.clamp(DEFAULT_WARP_BLEND + breathingStrength * 0.2, 0.25, 0.55);

    for (let i = 1; i < points.length - 1; i++) {
        const progress = i / (points.length - 1);
        const fade = THREE.MathUtils.smoothstep(progress, 0.05, 0.95);
        const baseWave = Math.sin(progress * Math.PI * (1.8 + wireframeDensity * 1.4)) * fade;
        const breath = Math.cos(progress * Math.PI * 1.4) * breathingStrength * fade;
        const macroCurve = Math.sin(progress * Math.PI * 0.85) * macroBend * fade;
        const macroRise = Math.cos(progress * Math.PI * 0.7) * macroLift * fade;
        const wave = baseWave + breath * 0.55;

        const basePrev = basePoints[i - 1];
        const baseCurrent = basePoints[i];
        const baseNext = basePoints[i + 1];

        prev.copy(basePrev);
        next.copy(baseNext);
        tangent.copy(baseNext).sub(basePrev);
        if (tangent.lengthSq() < 1e-6) continue;
        tangent.normalize();

        lateral.crossVectors(tangent, worldUp);
        if (lateral.lengthSq() < 1e-6) {
            lateral.set(1, 0, 0);
        } else {
            lateral.normalize();
        }

        let targetLat = wave * (5.5 + wireframeDensity * 3.4) + macroCurve;
        let targetVert = wave * (7.5 + breathingStrength * 3.6) + macroRise * 0.7;

        if (impossiblePhysicsEnabled) {
            targetLat += Math.cos(progress * Math.PI * 3.4 * impossiblePhysicsFrequency) * 2.0 * fade * impossiblePhysicsIntensity;
            targetVert += Math.sin(progress * Math.PI * 3.8 * impossiblePhysicsFrequency) * 2.2 * fade * impossiblePhysicsIntensity;
        }

        targetLat = THREE.MathUtils.clamp(targetLat, -MAX_DEFAULT_LATERAL_SHIFT, MAX_DEFAULT_LATERAL_SHIFT);
        targetVert = THREE.MathUtils.clamp(targetVert, -MAX_DEFAULT_VERTICAL_SHIFT, MAX_DEFAULT_VERTICAL_SHIFT);

        smoothedLateral = THREE.MathUtils.lerp(smoothedLateral, targetLat, 0.12);
        smoothedVertical = THREE.MathUtils.lerp(smoothedVertical, targetVert, 0.12);

        displaced.copy(baseCurrent)
            .addScaledVector(lateral, smoothedLateral)
            .addScaledVector(worldUp, smoothedVertical);

        points[i].lerpVectors(baseCurrent, displaced, warpBlend);
        upVectors[i].copy(baseUpVectors[i]).lerp(worldUp, warpBlend * 0.5).normalize();
    }
};
